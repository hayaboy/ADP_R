#=============================================================
#3.1 _ 평균
#=============================================================

# A식당의 배달시간 벡터 생성
storeA <- c(20,21,23,22,26,28,35,35,41,42,43,45,44,45,46,47,47,46,47,58,58,59,60,56,57,57,80)

# 평균을 구하는 함수 mean
mean(storeA)

#=============================================================
#3.2 _ 중간값
#=============================================================

# B식당의 배달시간 벡터 생성
storeB<- c(5,6,11,13,15,16,20,20,21,23,22,27,27,30,30,32,36,37,37,40,40,43,44,45,51,54,70,600)

# 평균
mean(storeB)

#-------------------------------------------------------------

# 600보다 작은 것만 선택
storeB[storeB < 600]

# 600보다 작은 것만 선택해 평균을 구함
mean(storeB[storeB < 600])

#-------------------------------------------------------------

# 벡터 선언
nums <- c(1, 5, 2, 3, 1000)

# 평균
mean(nums)

# 중간 값
median(nums)

#-------------------------------------------------------------

# 벡터 선언
nums <- c(1, 2, 5, 1000)

# 평균
mean(nums)

# 중간 값(정렬된 수 중에서 가운데 숫자 2와 5의 평균값)
median(nums)

#-------------------------------------------------------------

# A식당의 중간 값
median(storeA)

# B식당의 중간 값
median(storeB)

#=============================================================
#3.3 _ 사분위수
#=============================================================

# 벡터 선언
nums <- c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17)

# 사분위수는 quantile 함수로 산출
quantile(nums)

#-------------------------------------------------------------

# 중간 값이 동일한 집단 만들기
A <- c(0, 1, 1, 1, 5, 9, 9, 9, 10)
B <- c(0, 4, 4, 4, 5, 6, 6, 6, 10)

# A집단의 중간 값
median(A)

# B집단의 중간 값
median(B)

# A집단 사분위수 확인
quantile(A)

# B집단 사분위수 확인
quantile(B)

#-------------------------------------------------------------

# A식당 사분위수
quantile(storeA)
# B식당 사분위수
quantile(storeB)

#=============================================================
#3.4 _ 상자그림
#=============================================================

# 벡터 생성
boxNums<- c(21, 22, 23, 24, 25)

# 사분위수 확인
quantile(boxNums)

# 상자그림 그리기
boxplot(boxNums)

#-------------------------------------------------------------

# 벡터 생성 – 16과 30 이상치 추가
boxNums<- c(16, 21, 22, 23, 24, 25, 30)

# 사분위수 확인
quantile(boxNums)

# 상자그림 그리기
boxplot(boxNums)

#-------------------------------------------------------------

# 참고 storeB 배달시간 값
# (5,6,11,13,15,16,20,20,21,23,22,27,27,30,30,32,36,37,37,40,40,43,44,45,51,54,70,600)
# 상자그림 그리기
boxplot(storeB)

#-------------------------------------------------------------

# 600분 미만 배달시간만 감안
storeB <- storeB[storeB < 600]

# 상자그림 그리기
boxplot(storeB)

#-------------------------------------------------------------

# A식당 배달시간
storeA
# B식당 배달시간
storeB

# 상자그림 그리기/names 입력 항목을 통해 가로 축의 이름을 지정할 수 있습니다.
boxplot(storeA, storeB, names=c("A식당", "B식당"))

#-------------------------------------------------------------

# A식당과 B식당의 상자그림 그리기
boxplot(storeA, storeB , names=c("A식당", "B식당"))

# 그려진 상자그림에 평균을 추가로 표기
points(c( mean(storeA), mean(storeB)), pch=2, col="red", cex=2)

#-------------------------------------------------------------

# 벡터 생성
boxNums<- c(16, 21, 22, 23, 24, 25, 30)

# 상자그림 그리기(기본값: IQR * 1.5)
boxplot(boxNums)

# IQR * 2
boxplot(boxNums, range=2)

#-------------------------------------------------------------

# (이상치가 제거된) B식당의 배달시간 벡터 생성
storeB<- c(5,6,11,13,15,16,20,20,21,23,22,27,27,30,30,32,36,37,37,40,40,43,44,45,51,54,70)

# 평균
mean(storeB)

#사분위수
quantile(storeB)

# C식당의 배달시간 벡터 생성
storeC<-c (5,5,5,12,10,11,20,20,20,20,20,21,20,30,32,31,31,31,36,40,40,51,61,51,61,61,70)

# 평균
mean(storeC)

# 사분위수
quantile(storeC)

#-------------------------------------------------------------

# B식당과 C식당의 boxplot 그리기
boxplot(storeB, storeC, names=c("B식당", "C식당"))

#-------------------------------------------------------------

# 1사분위와 3사분위에 집중된 데이터 만들기
bpdat <- c(1, 50, 50, 50, 100, 100, 100, 150)

# 상자그림 생성
boxplot(bpdat)

#=============================================================
#3.5 _ 히스토그램
#=============================================================

# B식당 히스토그램 그리기
hist(storeB, main="B식당 배달시간 분포", xlab="배달시간 구간", ylab="건수")

#-------------------------------------------------------------

# C식당 히스토그램 그리기
hist(storeC, main="C식당 배달시간 분포", xlab ="배달시간 구간", ylab="건수")

#-------------------------------------------------------------

# B식당의 배달시간 벡터 정의
storeB <- c(5,6,11,13,15,16,20,20,21,23,22,27,27,30,30,32,36,37,37,40,40,43,44,45,51,54,70)

# 4개 구간으로 보기
hist(storeB, breaks=4)

# 구간 간격이 일정할 때는 세로축이 건수(frequency)로 표현됨
hist(storeB, breaks=c(0, 10, 20, 30, 40, 50, 60, 70))

# 구간 간격이 일정하지 않다면 기본적으로 세로축은 확률밀도로 표현됨
hist(storeB, breaks=c(0, 15, 25, 45, 70))

# 일정하지 않는 구간에도 freq 입력 항목을 사용해 세로축에 건수를 표현할 수도 있음
hist(storeB, breaks=c(0, 15, 25, 45, 70), freq=T)

#=============================================================
#3.6 _ 분산과 표준편차
#=============================================================

# B식당의 배달시간에 대한 분산
var(storeB)

# C식당의 배달시간에 대한 분산
var(storeC)

#-------------------------------------------------------------

# B식당 배달시간의 표준편차
sd(storeB)

# C식당 배달시간의 표준편차
sd(storeC)

#=============================================================
#3.7 _ 범주형 데이터 보기
#=============================================================

# 이슬반의 혈액형
bloodType <- c('A','B','A','AB','O','A','O','B','A','O','O','B','O','A','AB','B','O','A'

# 이슬반은 총 몇 명인가? (벡터 길이 확인)
length(bloodType)

#-------------------------------------------------------------

# 혈액형별 건수 보기
table(bloodType)

#-------------------------------------------------------------

# table 함수의 결과 객체 생성
table_bloodType <- table(bloodType)

# 결과 조회
table_bloodType

# 범주 확인하기
names(table_bloodType)

# 전체 합계 구하기
sum(table_bloodType)

#-------------------------------------------------------------

# 총계 붙여보기
addmargins(table(bloodType))

#-------------------------------------------------------------

# 파이차트 생성
pie(x=table(bloodType))

#-------------------------------------------------------------

# 라벨명, 색상, 선 종류, 차트 제목 지정
pie(x=table(bloodType)
, labels=c("A형", "AB형", "B형", "O형")
, col=c("chocolate1", "chartreuse2", "darkgoldenrod1", "darkorchid1")
, lty=2
, main="이슬반 혈액형 분포")

#-------------------------------------------------------------

# 색상명으로 색상 설정
pie(x=table(bloodType), col=c("blue", "skyblue", "lightcyan", "cyan"))

#-------------------------------------------------------------

colors()

#-------------------------------------------------------------

# heat.colors를 이용해 4개의 색상을 자동으로 선정
pie(x=table(bloodType), col=heat.colors(4))

#-------------------------------------------------------------

table(bloodType)

# 이슬반의 혈액형 분포를 막대차트로 표현
barplot(table(bloodType))

#-------------------------------------------------------------

# 막대 이름, 차트 제목, x축 이름, y축 이름, 색상 지정
barplot(table(bloodType)
, names.arg=c("A형", "AB형", "B형", "O형")
, main="이슬반의 혈액형 분포"
, xlab="혈액형"
, ylab="학생수"
, col=heat.colors(4)
)

#-------------------------------------------------------------

# classDf 구조 보기 – 20개 행, 3개 칼럼[이름(name) 성별(gender) 혈액형(bloodType)]
str(classDf)

# 이슬반의 혈액형 조사자료
classDf

#-------------------------------------------------------------

# classDf 2,3열의 첫 6행 보기
head(classDf[ , c(2,3)])

# classDf 중 성별(gender)과 혈액형(bloodType) 열만 선택해서 table 객체를 생성
table(classDf[ , c(2,3)])

# addmargins 함수를 활용해 합계 행과 열 추가
addmargins(table(classDf[ , c(2,3)]))

#-------------------------------------------------------------

# table 함수의 결괏값 객체 생성
classTable <- table(classDF[ , c(2, 3)])

# 막대차트를 활용해 성별과 혈액형별 분포 확인
barplot(classTable)

#-------------------------------------------------------------

# 범례 추가
barplot(classTable, legend=TRUE)

#-------------------------------------------------------------

# y축을 0 ~ 8까지 출력하도록 설정
barplot(classTable, legend=TRUE, ylim=c(0,8))

#-------------------------------------------------------------

# 색상 지정하기
barplot(classTable, legend=TRUE, ylim=c(0, 8), col=c("skyblue", "lightpink"))

#-------------------------------------------------------------

# beside 입력 항목을 활용해 성별을 별도 막대로 표기. 범례 영역을 위해 y축 길이를 설정(ylim)
barplot(classTable, legend=TRUE, ylim=c(0, 8), col=c("skyblue", "lightpink"), beside=T)

#-------------------------------------------------------------
#=============================================================
#3.8 _ 강력한 시각화 패키지 ggplot2
#=============================================================

# ggplot2 패키지 설치
library("ggplot2")

#-------------------------------------------------------------

# ggplot2 로드
library(ggplot2)

#-------------------------------------------------------------

# ggplot2 패키지 로드
library(ggplot2)

# 혈액별/성별 간 빈도수가 표현된 테이블 객체
classTable

# 데이터프레임 변환
classCovDF <- as.data.frame(classTable)

# 데이터프레임 변환 결과
classCovDF

# ggplot 함수 실행. aes를 통해 x/y축에 매핑할 데이터 항목을 지정
ggplot(classCovDF, aes(x=bloodType, y=Freq))

#-------------------------------------------------------------

# 막대차트 만들기
ggplot(classCovDF, aes(x=bloodType ,y=Freq)) + geom_col()

#-------------------------------------------------------------

# aes에 색상 채우기(fill)와 성별 항목 연결 추가
ggplot(classCovDF, aes(x=bloodType, y=Freq)) + geom_col(aes(fill=gender))

#-------------------------------------------------------------

# geom_point 추가. 점의 모양과 성별
ggplot(classCovDF, aes(x=bloodType,y=Freq)) + geom_col(aes(fill=gender)) + geom_point(aes(shape=gender), size=3)

#-------------------------------------------------------------

# geom_line 추가. 선 연결 기준(group)과 선 모양(linetype)을 성별과 연결한 aes 정보 추가
ggplot(classCovDF, aes(x=bloodType, y=Freq)) + geom_col(aes(fill=gender))+ geom_point(aes(shape=gender),size=3) + geom_line(aes(group=gender,linetype=gender))

#-------------------------------------------------------------

# ggplot의 제목 추가하기
ggplot(classCovDF, aes(x=bloodType, y=Freq)) + geom_col(aes(fill=gender)) + ggtitle("이슬반 혈액형 비율", subtitle="(혈액형/성별 기준)")

#-------------------------------------------------------------

# ggplot의 x/y축 및 범례 제목 변경
ggplot(classCovDF, aes(x=bloodType, y=Freq)) + geom_col(aes(fill=gender)) + ggtitle("이슬반 혈액형 비율", subtitle="(혈액형/성별 기준)") + labs(x="혈액형", y="인원수", fill="성별")

#-------------------------------------------------------------

# 그래프 객체 생성
BloodbarChart <- ggplot(classCovDF, aes(x=bloodType, y=Freq)) + 
                 geom_col(aes(fill=gender)) +
                 ggtitle("이슬반 혈액형 비율", subtitle="(혈액형/성별 기준)") + 
				 labs(x="혈액형", y="인원수", fill="성별")

# theme_void 적용
BloodbarChart + theme_void()

# theme_dark 적용
BloodbarChart + theme_dark()

# theme_minimal 적용
BloodbarChart + theme_minimal()

# theme_classic 적용
BloodbarChart + theme_classic()

#-------------------------------------------------------------

# + 기호를 행이 시작하는 위치에 입력 – 다른 명령어로 인식해 오류가 발생
ggplot(classDF, aes(x=bloodType, fill=gender)) + geom_bar()

#-------------------------------------------------------------

# + 기호는 이전 함수 뒤에 표현 – 정상 처리됨
ggplot(classDF, aes(x=bloodType, fill=gender)) + geom_bar()

#-------------------------------------------------------------

# 혈액형별 빈도수가 이미 계산된 경우
col_data

# x축에 혈액형, y축에 이미 계산된 빈도수를 연결해서 geom_col 함수로 막대차트를 생성
ggplot(col_data, aes(x=bloodType, y=Freq)) + geom_col()

#-------------------------------------------------------------

# 혈액형 정보가 나열돼 있음
bar_data

# x축에 혈액형을 연결하면 y축은 자동으로 빈도수를 계산해 표현
ggplot(bar_data, aes(x=bloodType)) + geom_bar()

#=============================================================
#3.9 _ 시간의 흐름에 따라 보기
#=============================================================

# A, B회사의 매출 실적 데이터프레임 만들기
company <- c('A', 'A', 'A', 'A', 'B', 'B', 'B', 'B')
year <- c('1980', '1990', '2000', '2010', '1980', '1990', '2000', '2010')
sales <- c(2750, 2800, 2830, 2840, 2760, 2765, 2775, 2790)

coSalesDF <- data.frame(company, year, sales)

# 생성된 coSalesDF 확인
coSalesDF

#-------------------------------------------------------------

# 라인차트 생성 - x축은 연도(year), y축은 매출(sales) 매칭
ggplot(coSalesDF, aes(x=year, y=sales)) + geom_line(aes(group=company))

#-------------------------------------------------------------

# 선 색상 및 두께 설정
ggplot(coSalesDF, aes(x=year, y=sales)) + geom_line(size=2, aes(group=company,colour=company))

#-------------------------------------------------------------

ggplot(coSalesDF, aes(x=year, y=sales)) + geom_line(size=2, aes(group=company, colour=company)) +

#=============================================================
#3.10 _ 상관관계 보기
#=============================================================

# cars 데이터 구조
str(cars)

#-------------------------------------------------------------

# plot (x축 데이터, y축 데이터, 옵션)
plot(cars$speed, cars$dist, xlab="속도", ylab="제동거리")

#-------------------------------------------------------------

# lowess 함수로 나온 회귀분석 추정치를 lines라는 함수를 통해 기존 그래프에 선을 추가
# 추세선
lines(lowess(cars$speed, cars$dist))

#-------------------------------------------------------------

# iris 데이터 구조
str(iris)

# 팩터 레벨 확인
levels(iris$Species)

# 데이터 프레임 내 모든 항목 간의 산점도 확인
plot(iris)

#-------------------------------------------------------------

plot(iris$Petal.Width, iris$Petal.Length)

#-------------------------------------------------------------

# 팩터 레벨 확인
levels(iris$Species)

#-------------------------------------------------------------

# iris 데이터셋
str(iris)

# 꽃받침(sepal) 길이와 너비의 상관계수 산출
cor(iris$Sepal.Length, iris$Sepal.Width)

#-------------------------------------------------------------

# 꽃받침(sepal) 길이와 너비
plot(iris$Sepal.Length, iris$Sepal.Width)

#-------------------------------------------------------------

# 꽃잎(Petal) 길이와 너비의 상관계수 산출
cor(iris$Petal.Length, iris$Petal.Width)

# 꽃잎(Petal) 길이와 너비의 산점도
plot(iris$Petal.Length, iris$Petal.Width)

#=============================================================
#3.11 _ 트리맵
#=============================================================

# 데이터파일 엑셀(시작하세요_데이터분석withR_데이터셋.xlsx)에서 "3.11_sales_df" Sheet 복사 후 
# 아래 명령어를 실행 해 데이터 프레임 생성  
sales_df <- read.table (file = "clipboard", header=TRUE , sep="\t")


# A기업의 판매현황 – 상품(product), 지역(region), 매출(saleAmt)
str(sales_df)

# 데이터 보기
sales_df

#-------------------------------------------------------------

# 트리맵 라이브러리 설치
install.packages("treemap")

# 트리맵 메모리 로드
library(treemap)

#-------------------------------------------------------------

# 트리맵 그리기
# index에 표현하고 싶은 계층 순서대로 벡터로 생성. product, region 순으로 벡터를 지정함으로써 product가 region보다 더 상위로 구분이 됨
treemap(sales_df, vSize="saleAmt", index=c("product", "region"), title="A기업 판매현황")

#-------------------------------------------------------------

# 트리맵 그리기
treemap(sales_df, vSize="saleAmt", index=c("region", "product"), title="A기업 판매현황")

#=============================================================
#3.12 _ 워드 클라우드
#=============================================================

searchString <- "query=코타키나발루"

# 2.1 UTF-8 인코딩
searchString <- iconv(searchString, to= "UTF-8")

# 2.2 URL 인코딩
searchString <-URLencode(searchString)

# 2.3 인코딩된 내역 확인
searchString

# 3. 나머지 요청변수 설정(각 요청변수는 &로 연결)
# 조회 개수 100개, 시작 페이지 1, 유사도순 정렬
etcString <- "&display=100&start=1&sort=sim"

# 4. URL 조립
reqUrl <- paste(urlStr, searchString, etcString, sep="")

# 5. 조립된 URL 확인
reqUrl

#-------------------------------------------------------------

# 최초 실행 시 패키지 설치
install.packages("httr")

# 패키지 로드
library(httr)

# Client ID 설정
clientId <- "tLGBFjnRy1810bC8GPVU"

# Client Secret 설정
clientSecret <- "g6G58StAox"

# GET 함수 호출(인증정보는 add_headers에 담아 함께 전송)
apiResult <- GET(reqUrl, add_headers("X-Naver-Client-Id"=clientId, "X-Naver-Client-

# 호출 결과 조회(응답코드(status)가 200이면 정상)
apiResult

# Open API의 결과 구조 확인
str(apiResult)

#-------------------------------------------------------------

# 응답 결과 내용 확인
apiResult$content

# content 요소 확인
str(apiResult$content)

#-------------------------------------------------------------

# raw 형을 문자로 변환
result <- rawToChar(apiResult$content)

# 변환 결과 확인(한글이 깨져 있음)
result

# UTF-8 인코딩
Encoding(result) <- "UTF-8"

# 변환 결과 확인(한글이 정상적으로 출력됨)
result

#-------------------------------------------------------------

# ABC를 ***로 변환
gsub("ABC", "***", "ABCabcABC")

# 대소문자를 무시하고 변환
gsub("ABC", "***", "ABCabcABC" , ignore.case=T)

# 벡터 문자열 치환
x <- c("ABCabcABC", "abcABCabc")
gsub("ABC", "***", x)

#-------------------------------------------------------------

# b와 n 사이에 문자 1개가 있는 패턴은 ***로 치환
gsub("b.n", "***", "i love banana")

# b 이후 문자가 0개 이상 있고 a로 끝나는 패턴은 ***로 치환
gsub("b.*a", "***", "i love banana")

# ba와 na는 ***로 치환
gsub("[bn]a", "***", "i love banana")

# 핸드폰 전화번호 패턴: 010-숫자4개-숫자4개
gsub("010-[0-9]{4}-[0-9]{4}", "010-****-****", "내 폰 번호는 010-9123-0000")

# 핸드폰 전화번호 패턴: 010-숫자4개-숫자4개
gsub("010-\\d{4}-\\d{4}", "010-****-****", "내 폰 번호는 010-9123-0000")

#-------------------------------------------------------------

# 변경 전 검색 결과
result

# 검색 결과를 변수에 저장
refinedStr <- result

# XML 태그를 공란으로 치환
refinedStr <- gsub("<(\\/?)(\\w +)*([^<>]*)>", " ", refinedStr)

# 단락을 표현하는 불필요한 문자를 공란으로 치환
refinedStr <- gsub("[[:punct:]]", " ", refinedStr)

# 영어 소문자를 공란으로 치환
refinedStr <- gsub("[a-z]", " ", refinedStr)

# 숫자를 공란으로 치환
refinedStr <- gsub("[0-9]", " ", refinedStr)

# 여러 공란은 한 개의 공란으로 변경
refinedStr <- gsub(" +", " ", refinedStr)

# 변경 후의 검색 결과
refinedStr

#-------------------------------------------------------------

# 최초 실행 시 패키지 설치
install.packages("KoNLP")

# 패키지 로드
library(KoNLP)

# 단어 추출 테스트
extractNoun("안녕하세요 오늘은 기분 좋은 하루 입니다.")

#-------------------------------------------------------------

# 검색 문장 내 단어 추출
nouns <- extractNoun(refinedStr)

# 단어 추출 결과 확인
str(nouns)

# 추출된 단어 중 일부를 확인(앞에서부터 40개)
nouns[1:40]

#-------------------------------------------------------------

# 길이가 1인 문자를 제외
nouns <- nouns[nchar(nouns) > 1]

# 제외할 특정 단어를 정의
excluNouns <- c("코타키나발루", "얼마", "오늘", "으로", "해서", "API", "저희", "정도")

# 특정 단어를 제외
nouns <- nouns [!nouns %in% excluNouns]

# 추출된 단어 중 일부를 확인(앞에서부터 40개)
nouns[1:40]

#-------------------------------------------------------------

# 빈도수(table)를 기준으로 내림차순(decreasing=T) 정렬(sort) -> 상위 50개만 추출([1:50])
wordT <- sort(table(nouns), decreasing=T)[1:50]

# 추출 결과 확인
wordT

#-------------------------------------------------------------

# 최초 실행 시 패키지 설치
install.packages("wordcloud2")

# 패키지 로드
library(wordcloud2)

# 워드 클라우드 그리기
wordcloud2(wordT, size = 3, shape='diamond')

#-------------------------------------------------------------
